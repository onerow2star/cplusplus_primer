函数由返回类型 函数名 0个或多个形参组成的列表以及函数体

我们通过调用运算符来执行函数 其形式是圆括号 里面是用逗号隔开的实参 函数调用需要 实参初始化函数对应的形参 将控制权转移给被调用函数 主调函数的执行被暂时中断 被调函数开始执行 执行第一步隐式定义并处死话形参 遇到return 结束调用将控制权转移至主调函数上 

实参是形参的初始值 形参虽然与实参对应 但是并没有规定实参的求值顺序 编译器任意可行顺序求值

实参形参类型 数量必须匹配  类型可以转换
`const char*`不能转为`int` `double`可以

形参列表可以为空 但不能省略 为了和C语言兼容 可以用`void` 类型即使一样也得把两个类型都写出来
```cpp
void f1(){}
void f2(void){}
// int f3(int v1, v2) // error
int f4(int v1, int v2)
```

形参一般都会提供一个名字 个别形参不会用到也必须提供一个实参
返回类型void表示不返回任何值 不能返回数组或函数类型 但可以返回指向他们的指针  甚至可以返回数组的引用

名字有作用域

对象有生命周期

函数体是一个语句块 形参和函数体的内部定义的局部变量 局部变量还会隐藏外层作用域同名的其他所有声明 

我们把只存在于块执行期间的对象成为自动对象 形参是一种自动对象 执行结束自动对象变为未定义

有时候有必要将局部变量的生命周期贯穿函数调用之后 局部静态对象就是在程序的执行路径第一次定义初始化 直到程序终止时销毁 在次旗舰即使函数结束也不会对其影响

```cpp
size_t count_calls()
{
    static size_t ctr = 0; // 调用结束后这个值仍然有效
    return ++ctr;
}
int main()
{
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
```
第一次经过`ctr`定义 `ctr`创建并初始化为`0`每次函数调用`ctr`会被赋予新值 如果局部静态变量没有显示的初始值 执行默认初始化