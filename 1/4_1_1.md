表达式由一个或多个运算对象组成 对表达式求值能得到一个结果 字面值和变量是最简单的表达式 把运算符和一个或多个运算对象组合可以形成复杂表达式

C++ 一元运算符和二元运算符

多个运算符 考虑优先级 结合律 求值顺序

运算中会有类型转换 指针不会转为浮点数 小整数`bool` `char` `short`通常转为为较大整数类型 `int`

运算符重载 当运算符作为类类型的运算对象可以自行定义其含义 IO的`<<` `>>`以及`string` `vector`和迭代器使用的运算符都是重载的运算符

右值 左值 

C语言左值可以位于赋值语句的左侧 右值不能

在C中，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)

以常量为代表的左值 不能作为赋值运算 

C++ 
当一个对象最为右值 是对象的值(内容) 不在内存中占有特定位置
当对象作为左值时 用的对象的身份 是在内存中的位置

`volatile`提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

1. 对于基础类型，右值是不可被修改的(non-modifiable)，也不可被 `const`, `volatile` 所修饰(cv-qualitification ignored)

2. 对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改。

1.这和C是一致的，2. 却是 C++ 中所独有

因为通常来说，自定义类型应该设计得和内置类型尽量一样(所谓 value type,value semantic)，但允许成员函数改变右值这个特性却有意无意使得自定义类型特殊化了。对此，我们其实可以这样想，也许会好理解点：自定义类型允许有成员函数，而通过右值调用成员函数是被允许的，但成员函数有可能不是 const 类型，因此通过调用右值的成员函数，也就可能会修改了该右值

已经使用的左值
赋值运算符需要一个左值作为左侧运算对象 得到的也是左值
取地址符作用与一个左值 返回一个指针 该指针是一个右值 
解引用 下标运算符 迭代器解引用 `string` `vector`下标运算符 求值结果都是左值
内置类型 和迭代器 递增递减都是左值
`decltype`作用于左值的带的一个引用类型
`decltype`作用于右值 是一个指针指向指针
```cpp
int *p;
decltype(*p)  // int&  引用
decltype(&p) // int** 指向指针的指针
```
